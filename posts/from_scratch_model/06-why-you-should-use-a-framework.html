<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Sean Lewis">
<meta name="dcterms.date" content="2025-02-23">
<meta name="description" content="This is the second notebook in the fast.ai lecture for #5">

<title>06-Why you should use a Framework (follow Along) – Sean Lewis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-bd8cb2610f6c2810c4bc87234a365cf8.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Sean Lewis</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/seanlewis08"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/selew/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction-and-set-up" id="toc-introduction-and-set-up" class="nav-link active" data-scroll-target="#introduction-and-set-up">Introduction and set up</a></li>
  <li><a href="#prep-the-data" id="toc-prep-the-data" class="nav-link" data-scroll-target="#prep-the-data">Prep the data</a></li>
  <li><a href="#train-the-model" id="toc-train-the-model" class="nav-link" data-scroll-target="#train-the-model">Train the model</a></li>
  <li><a href="#submit-to-kaggle" id="toc-submit-to-kaggle" class="nav-link" data-scroll-target="#submit-to-kaggle">Submit to Kaggle</a></li>
  <li><a href="#ensembling" id="toc-ensembling" class="nav-link" data-scroll-target="#ensembling">Ensembling</a></li>
  <li><a href="#final-thoughts" id="toc-final-thoughts" class="nav-link" data-scroll-target="#final-thoughts">Final thoughts</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">06-Why you should use a Framework (follow Along)</h1>
  <div class="quarto-categories">
    <div class="quarto-category">nueral net</div>
    <div class="quarto-category">from scratch</div>
  </div>
  </div>

<div>
  <div class="description">
    This is the second notebook in the fast.ai lecture for #5
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Sean Lewis </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 23, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction-and-set-up" class="level2">
<h2 class="anchored" data-anchor-id="introduction-and-set-up">Introduction and set up</h2>
<p>If you’ve finished going through my <a href="https://www.kaggle.com/code/jhoward/linear-model-and-neural-net-from-scratch">Linear model and neural net from scratch</a> notebook, then now is a good time to look at how to do the same thing using a library, instead of doing it from scratch. We’ll use fastai and PyTorch. The benefits of using these libraries is:- Best practices are handled for you automatically – fast.ai has done thousands of hours of experiments to figure out what the best settings are for you- Less time getting set up, which means more time to try out your new ideas- Each idea you try will be less work, because fastai and PyTorch will do the many of the menial bits for you- You can always drop down from fastai to PyTorch if you need to customise any part (or drop down from the fastai Application API to the fastai mid or low tier APIs), or even drop down from PyTorch to plain python for deep customisation.Let’s see how that looks in practice. We’ll start by doing the same library setup as in the “from scratch” notebook:</p>
<p>::: {#cell-3 .cell _kg_hide-output=‘true’ execution=‘{“iopub.status.busy”:“2022-05-16T21:26:52.397584Z”,“iopub.execute_input”:“2022-05-16T21:26:52.398131Z”,“iopub.status.idle”:“2022-05-16T21:27:20.193935Z”,“shell.execute_reply.started”:“2022-05-16T21:26:52.398019Z”,“shell.execute_reply”:“2022-05-16T21:27:20.193065Z”}’ trusted=‘true’}</p>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Pathimport osiskaggle <span class="op">=</span> os.environ.get(<span class="st">'KAGGLE_KERNEL_RUN_TYPE'</span>, <span class="st">''</span>)<span class="cf">if</span> iskaggle:    path <span class="op">=</span> Path(<span class="st">'../input/titanic'</span>)    <span class="op">!</span>pip install <span class="op">-</span>Uqq fastaielse:    <span class="im">import</span> zipfile,kaggle    path <span class="op">=</span> Path(<span class="st">'titanic'</span>)    kaggle.api.competition_download_cli(<span class="bu">str</span>(path))    zipfile.ZipFile(<span class="ss">f'</span><span class="sc">{</span>path<span class="sc">}</span><span class="ss">.zip'</span>).extractall(path)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>:::</p>
<p>We’ll import the fastai tabular library, set a random seed so the notebook is reproducible, and pick a reasonable number of significant figures to display in our tables:</p>
<div id="cell-5" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:27:20.196442Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:27:20.196812Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:27:23.389486Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:27:20.196763Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:27:23.388493Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastai.tabular.<span class="bu">all</span> <span class="im">import</span> <span class="op">*</span>pd.options.display.float_format <span class="op">=</span> <span class="st">'</span><span class="sc">{:.2f}</span><span class="st">'</span>.formatset_seed(<span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="prep-the-data" class="level2">
<h2 class="anchored" data-anchor-id="prep-the-data">Prep the data</h2>
<p>We’ll read the CSV file just like we did before:</p>
<div id="cell-8" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:27:23.390719Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:27:23.390946Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:27:23.41585Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:27:23.390919Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:27:23.414775Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(path<span class="op">/</span><span class="st">'train.csv'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>When you do everything from scratch, every bit of feature engineering requires a whole lot of work, since you have to think about things like dummy variables, normalization, missing values, and so on. But with fastai that’s all done for you. So let’s go wild and create lots of new features! We’ll use a bunch of the most interesting ones from this fantastic <a href="https://www.kaggle.com/code/gunesevitan/titanic-advanced-feature-engineering-tutorial/">Titanic feature engineering notebook</a> (and be sure to click that link and upvote that notebook if you like it to thank the author for their hard work!)</p>
<div id="cell-10" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:27:23.417899Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:27:23.418374Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:27:23.608237Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:27:23.41833Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:27:23.606987Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_features(df):    df[<span class="st">'LogFare'</span>] <span class="op">=</span> np.log1p(df[<span class="st">'Fare'</span>])    df[<span class="st">'Deck'</span>] <span class="op">=</span> df.Cabin.<span class="bu">str</span>[<span class="dv">0</span>].<span class="bu">map</span>(<span class="bu">dict</span>(A<span class="op">=</span><span class="st">"ABC"</span>, B<span class="op">=</span><span class="st">"ABC"</span>, C<span class="op">=</span><span class="st">"ABC"</span>, D<span class="op">=</span><span class="st">"DE"</span>, E<span class="op">=</span><span class="st">"DE"</span>, F<span class="op">=</span><span class="st">"FG"</span>, G<span class="op">=</span><span class="st">"FG"</span>))    df[<span class="st">'Family'</span>] <span class="op">=</span> df.SibSp<span class="op">+</span>df.Parch    df[<span class="st">'Alone'</span>] <span class="op">=</span> df.Family<span class="op">==</span><span class="dv">1</span>    df[<span class="st">'TicketFreq'</span>] <span class="op">=</span> df.groupby(<span class="st">'Ticket'</span>)[<span class="st">'Ticket'</span>].transform(<span class="st">'count'</span>)    df[<span class="st">'Title'</span>] <span class="op">=</span> df.Name.<span class="bu">str</span>.split(<span class="st">', '</span>, expand<span class="op">=</span><span class="va">True</span>)[<span class="dv">1</span>].<span class="bu">str</span>.split(<span class="st">'.'</span>, expand<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]    df[<span class="st">'Title'</span>] <span class="op">=</span> df.Title.<span class="bu">map</span>(<span class="bu">dict</span>(Mr<span class="op">=</span><span class="st">"Mr"</span>,Miss<span class="op">=</span><span class="st">"Miss"</span>,Mrs<span class="op">=</span><span class="st">"Mrs"</span>,Master<span class="op">=</span><span class="st">"Master"</span>)).value_counts(dropna<span class="op">=</span><span class="va">False</span>)add_features(df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As we discussed in the last notebook, we can use <code>RandomSplitter</code> to separate out the training and validation sets:</p>
<div id="cell-12" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:27:23.609777Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:27:23.610261Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:27:23.617051Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:27:23.610212Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:27:23.616183Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>splits <span class="op">=</span> RandomSplitter(seed<span class="op">=</span><span class="dv">42</span>)(df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now the entire process of getting the data ready for training requires just this one cell!:</p>
<div id="cell-14" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:27:23.618653Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:27:23.619435Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:27:23.706067Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:27:23.619384Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:27:23.705359Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>dls <span class="op">=</span> TabularPandas(    df, splits<span class="op">=</span>splits,    procs <span class="op">=</span> [Categorify, FillMissing, Normalize],    cat_names<span class="op">=</span>[<span class="st">"Sex"</span>,<span class="st">"Pclass"</span>,<span class="st">"Embarked"</span>,<span class="st">"Deck"</span>, <span class="st">"Title"</span>],    cont_names<span class="op">=</span>[<span class="st">'Age'</span>, <span class="st">'SibSp'</span>, <span class="st">'Parch'</span>, <span class="st">'LogFare'</span>, <span class="st">'Alone'</span>, <span class="st">'TicketFreq'</span>, <span class="st">'Family'</span>],    y_names<span class="op">=</span><span class="st">"Survived"</span>, y_block <span class="op">=</span> CategoryBlock(),).dataloaders(path<span class="op">=</span><span class="st">"."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here’s what each of the parameters means:- Use <code>splits</code> for indices of training and validation sets: splits=splits, - Turn strings into categories, fill missing values in numeric columns with the median, normalise all numeric columns: procs = [Categorify, FillMissing, Normalize], - These are the categorical independent variables: cat_names=[“Sex”,“Pclass”,“Embarked”,“Deck”, “Title”], - These are the continuous independent variables: cont_names=[‘Age’, ‘SibSp’, ‘Parch’, ‘LogFare’, ‘Alone’, ‘TicketFreq’, ‘Family’], - This is the dependent variable: y_names=“Survived”,- The dependent variable is categorical (so build a classification model, not a regression model): y_block = CategoryBlock(),</p>
</section>
<section id="train-the-model" class="level2">
<h2 class="anchored" data-anchor-id="train-the-model">Train the model</h2>
<p>The data and model together make up a <code>Learner</code>. To create one, we say what the data is (<code>dls</code>), and the size of each hidden layer (<code>[10,10]</code>), along with any metrics we want to print along the way:</p>
<div id="cell-18" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:27:23.707298Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:27:23.707789Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:27:23.726787Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:27:23.707741Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:27:23.725748Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>learn <span class="op">=</span> tabular_learner(dls, metrics<span class="op">=</span>accuracy, layers<span class="op">=</span>[<span class="dv">10</span>,<span class="dv">10</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>You’ll notice we didn’t have to do any messing around to try to find a set of random coefficients that will train correctly – that’s all handled automatically.One handy feature that fastai can also tell us what learning rate to use:</p>
<div id="cell-20" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:27:23.728203Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:27:23.731489Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:27:25.934408Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:27:23.731434Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:27:25.933704Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>learn.lr_find(suggest_funcs<span class="op">=</span>(slide, valley))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The two colored points are both reasonable choices for a learning rate. I’ll pick somewhere between the two (0.03) and train for a few epochs:</p>
<div id="cell-22" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:27:25.935368Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:27:25.935688Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:27:28.235979Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:27:25.93566Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:27:28.235073Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>learn.fit(<span class="dv">16</span>, lr<span class="op">=</span><span class="fl">0.03</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We’ve got a similar accuracy to our previous “from scratch” model – which isn’t too surprising, since as we discussed, this dataset is too small and simple to really see much difference. A simple linear model already does a pretty good job. But that’s OK – the goal here is to show you how to get started with deep learning and understand how it really works, and the best way to do that is on small and easy to understand datasets.</p>
</section>
<section id="submit-to-kaggle" class="level2">
<h2 class="anchored" data-anchor-id="submit-to-kaggle">Submit to Kaggle</h2>
<p>One important feature of fastai is that all the information needed to apply the data transformations and the model to a new dataset are stored in the learner. You can call <code>export</code> to save it to a file to use it later in production, or you can use the trained model right away to get predictions on a test set.To submit to Kaggle, we’ll need to read in the test set, and do the same feature engineering we did for the training set:</p>
<div id="cell-26" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:31:03.526802Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:31:03.527206Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:31:03.559518Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:31:03.527162Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:31:03.558458Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>tst_df <span class="op">=</span> pd.read_csv(path<span class="op">/</span><span class="st">'test.csv'</span>)tst_df[<span class="st">'Fare'</span>] <span class="op">=</span> tst_df.Fare.fillna(<span class="dv">0</span>)add_features(tst_df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>But we don’t need to manually specify any of the processing steps necessary to get the data ready for modeling, since that’s all saved in the learner. To specify we want to apply the same steps to a new dataset, use the <code>test_dl()</code> method:</p>
<div id="cell-28" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:31:03.826524Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:31:03.827754Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:31:03.854977Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:31:03.827684Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:31:03.85406Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>tst_dl <span class="op">=</span> learn.dls.test_dl(tst_df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can use <code>get_preds</code> to get the predictions for the test set:</p>
<div id="cell-30" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:31:04.505947Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:31:04.506524Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:31:04.586309Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:31:04.506482Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:31:04.585385Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>preds,_ <span class="op">=</span> learn.get_preds(dl<span class="op">=</span>tst_dl)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, let’s create a submission CSV just like we did in the previous notebook…</p>
<div id="cell-32" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:31:05.603891Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:31:05.604749Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:31:05.619653Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:31:05.604676Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:31:05.618707Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>tst_df[<span class="st">'Survived'</span>] <span class="op">=</span> (preds[:,<span class="dv">1</span>]<span class="op">&gt;</span><span class="fl">0.5</span>).<span class="bu">int</span>()sub_df <span class="op">=</span> tst_df[[<span class="st">'PassengerId'</span>,<span class="st">'Survived'</span>]]sub_df.to_csv(<span class="st">'sub.csv'</span>, index<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>…and check that it looks reasonable:</p>
<div id="cell-34" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:31:07.007378Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:31:07.008492Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:31:07.819079Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:31:07.008411Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:31:07.817493Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>head sub.csv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="ensembling" class="level2">
<h2 class="anchored" data-anchor-id="ensembling">Ensembling</h2>
<p>Since it’s so easy to create a model now, it’s easier to play with more advanced modeling approaches. For instance, we can create five separate models, each trained from different random starting points, and average them. This is the simplest approach of <a href="https://machinelearningmastery.com/tour-of-ensemble-learning-algorithms/">ensembling</a> models, which combines multiple models to generate predictions that are better than any of the single models in the ensemble.To create our ensemble, first we copy the three steps we used above to create and train a model, and apply it to the test set:</p>
<div id="cell-37" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:31:14.094621Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:31:14.095657Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:31:14.10358Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:31:14.095606Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:31:14.102546Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ensemble():    learn <span class="op">=</span> tabular_learner(dls, metrics<span class="op">=</span>accuracy, layers<span class="op">=</span>[<span class="dv">10</span>,<span class="dv">10</span>])    <span class="cf">with</span> learn.no_bar(),learn.no_logging(): learn.fit(<span class="dv">16</span>, lr<span class="op">=</span><span class="fl">0.03</span>)    <span class="cf">return</span> learn.get_preds(dl<span class="op">=</span>tst_dl)[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we run this five times, and collect the results into a list:</p>
<div id="cell-39" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:31:14.618981Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:31:14.620018Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:31:24.138634Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:31:14.61996Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:31:24.137567Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>learns <span class="op">=</span> [ensemble() <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We stack this predictions together and take their average predictions:</p>
<div id="cell-41" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:32:57.494424Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:32:57.495125Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:32:57.499817Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:32:57.49506Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:32:57.498927Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>ens_preds <span class="op">=</span> torch.stack(learns).mean(<span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, use the same code as before to generate a submission file, which we can submit to Kaggle after the notebook is saved and run:</p>
<div id="cell-43" class="cell" data-execution="{&quot;iopub.status.busy&quot;:&quot;2022-05-16T21:33:20.950176Z&quot;,&quot;iopub.execute_input&quot;:&quot;2022-05-16T21:33:20.951163Z&quot;,&quot;iopub.status.idle&quot;:&quot;2022-05-16T21:33:20.960718Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2022-05-16T21:33:20.951112Z&quot;,&quot;shell.execute_reply&quot;:&quot;2022-05-16T21:33:20.959421Z&quot;}" data-trusted="true">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>tst_df[<span class="st">'Survived'</span>] <span class="op">=</span> (ens_preds[:,<span class="dv">1</span>]<span class="op">&gt;</span><span class="fl">0.5</span>).<span class="bu">int</span>()sub_df <span class="op">=</span> tst_df[[<span class="st">'PassengerId'</span>,<span class="st">'Survived'</span>]]sub_df.to_csv(<span class="st">'ens_sub.csv'</span>, index<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>At the time of writing, this submission is well within the top 25% of entries to the competition.(A lot of submissions to this competition use additional external data, but we have restricted ourselves to just using the data provided. We’d probably do a lot better if we used external data too. Feel free to give that a try, and see how you go. Note that you’ll never be able to get to the top of the leaderboard, since a lot of folks in this competition have cheated, by downloading the answers from the internet and uploading them as their submission. In a real competition that’s not possible, because the answers aren’t public, but there’s nothing stopping people from cheating in a tutorial/practice competition like this one. So if you’re ready for a real challenge, take a look at the <a href="https://www.kaggle.com/competitions/">competitions page</a> and start working on a real competition!)</p>
</section>
<section id="final-thoughts" class="level2">
<h2 class="anchored" data-anchor-id="final-thoughts">Final thoughts</h2>
<p>As you can see, using fastai and PyTorch made things much easier than doing it from scratch, but it also hid away a lot of the details. So if you only ever use a framework, you’re not going to as fully understand what’s going on under the hood. That understanding can be really helpful when it comes to debugging and improving your models. But do use fastai when you’re creating models on Kaggle or in “real life”, because otherwise you’re not taking advantage of all the research that’s gone into optimising the models for you, and you’ll end up spending more time debugging and implementing menial boiler-plate than actually solving the real problem!If you found this notebook useful, please remember to click the little up-arrow at the top to upvote it, since I like to know when people have found my work useful, and it helps others find it too. (BTW, be sure you’re looking at my <a href="https://www.kaggle.com/jhoward/why-you-should-use-a-framework">original notebook</a> here when you do that, and are not on your own copy of it, otherwise your upvote won’t get counted!) And if you have any questions or comments, please pop them below – I read every comment I receive!</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/seanlewis08\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="seanlewis08/blogComments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>